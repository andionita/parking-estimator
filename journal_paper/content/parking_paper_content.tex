\section{Introduction}
Parking is a known problem in cities.
Worldwide we are experiencing an increase in the number of cars~\cite{car_increase}.
Currently, about 30\% of the traffic in cities is caused by cars that are actively searching for parking~\cite{traffic_congestion}.
Drivers often end up double-parking their cars, which blocks other cars, thus causing unneeded stress.
Drivers that are circling for a parking space may cause safety issues, as they are often distracted and are not paying attention to cyclists and pedestrians.
When circling for parking spaces, additional fuel is consumed, which has an economical as well as an environmental impact.

Existing parking spaces can be more efficiently occupied if the drivers know about their availability.
This information needs to be available in advance, so that drivers can take the decision to drive towards a highly probable free parking space early enough and not get stuck in a traffic bottleneck.
A software system predicting available spaces would, ideally, take into account factors such as current parking space availability, traffic, events in the near vicinity, weather, and many more.
Existing forecasting systems often start by collecting statistics on available parking spaces.
Usually, mounted sensors observe when a car occupies and leaves a parking space.
Acquiring the required data, however, be it on the parking spaces themselves or the complementary information, is, most of the time, the bottleneck for these approaches. 

Our approach introduces the notion of a \textit{parking demand profile}, which reflects the time of the day where parking occurs and its duration for a given area.
Furthermore, we examine how machine learning models for parking occupancy can be transferred between city areas with a similar profile.
We start by giving an intuitive example which bridges the understanding path towards the rest of the work.
Further, other contributions to the field of smart parking are presented, followed by the concrete approach.
The evaluation in this case carries out the instantiation of the proposed approach with an actual use case. We present the results and an analysis.
We finish off by pointing out aspects that can be further pursued and by summarizing the outcome.
This work is a short version of an earlier master thesis by the first author of this article~\cite{ionita2017master}.

\section{Motivating Example}
In this section, we provide a motivating example illustrating the necessity for introducing the concept of \emph{parking demand profiles} to improve the accuracy of machine learning models for predicting free parking spots in smart cities. 

The scenario consists of a large smart city with different parking areas, which are either dedicated parking spots (e.g., car parks or parking lots) or parking spaces on the side of the street. Some of these parking areas are equipped with sensors to measure the occupancy rate whereas other areas are tracked using cameras or parking meters. Due to the high costs for tracking all parking areas (especially those which offer free parking), most parking areas are not tracked at all. To improve the parking situation in the city, the local government decides to publish the available data sources, such as the sensor measurements, on their Open Data platform. 

Data scientists can now obtain the data and start building predictive models for parking areas at which data are available. For that, the data scientist examines the data, performs feature engineering and selection, trains the models and develops an application that predicts the occupancy rates for different locations of the city. 

Examining this scenario, we identify several drawbacks. Due to the heterogeneity of available parking data sources and information, it becomes quite hard for the data scientist to build the models. 
First, the data scientist has to understand each data source in detail based on the information provided on the Open Data platform. 
If the data were provided homogeneously (e.g., by using RDF and a well-defined ontology), it would become easier for the data scientist to understand the data from one source and to aggregate the data from multiple sources. 
In addition, the application can be used in other cities, which provide their data based on the same ontology.

Besides the understanding of the data, the data scientist still faces the problem of not covering all parking areas of the city. 
If we assume that different models for the different parking areas have been built, it is unclear whether any of these models can be applied on untracked areas. 
Hence, our approach exploits the use of parking profiles which represent parking in a city area. One example would be an area consisting of office buildings. Here, parking demand is usually high during working time, e.g., between 8 and 18 o'clock. Two such areas, perhaps in different parts of a city, or even in different cities, likely have a similar parking situation, i.e., between 8 and 18 on weekdays there is a high parking demand. In case of restaurants, on the other hand, we see a spike in parking demand in the evening, usually from 18 until 22, and even more so on weekends. In residential areas, the cars are parked in the evening and leave again early in the morning. A measure that would capture parking demand will therefore be based on the stay duration of customers or employees of the particular services, the available number of shops and restaurants or other point of interests (e.g., event halls). 

For such city areas (e.g., office buildings, restaurants, residential areas, etc.) that have parking occupancy data, the data scientist can build the predictive models. 
Then, using parking profiles, one can attempt using models created for tracked areas in untracked ones. 
Hence, we investigate in this article how we can transfer these models to other city areas for which no parking occupancy data is available, but that have similar parking demand profiles. 

\section{Related Work}
\label{sec:relwork}
The goal of improving the parking situation by estimating free parking spots is well known for many decades. 
Hence, there are many works related to the problem we are addressing.

Xu et al.~\cite{xu} make real-time parking availability estimations based on data collected from mobile phones. The system uses algorithms incorporating statistical weighted schemes and Kalman filters. Additionally, the authors create parking availability profiles based on historical data and statistical algorithms.

Other works making use of smart phones are the ones by Nandugudi et al.~\cite{nandugudi}, Koster et al.~\cite{koster}, and Chen et al.~\cite{zchen}.
After data collection, often using the sensors in the smartphone, they use different machine learning models, such as probabilistic distribution, Bayesian, and Hidden Markov models, as well as fuzzy logic to predict the available parking spaces.

Instead of using mobile devices that are carried by drivers, Park-Net, developed by Mathur et al.~\cite{mathur} is a system made up of dedicated vehicles that captures parking space information while driving. Every ParkNet vehicle is equipped with a GPS receiver and an ultrasonic sensor facing sideways. The latter determines whether it passes by parking spaces and whether they are occupied. The data is sent to a central server that aggregates it, in order to build parking space occupancy maps in real-time. The information is queried by clients that search for a free parking space. The system was evaluated in Highland Park, New Jersey and San Francisco on 500 miles road-side parking data and yield 95\% accurate parking maps and 90\% parking occupancy accuracy.

Compared to approaches that collect data via mobile phones or dedicated cars, other approaches use data collected by sensors, parking meters or cameras that are installed on streets or parking lots. For instance, Tiedemann et al.~\cite{tiedemann} developed a prediction system that gives estimated occupancies for parking spaces in Berlin, Germany. The occupancy data is collected online via roadside parking sensors and the prediction is realized using neural gas machine learning combined with data threads. The authors notice that some factors play a significant part in the predictions, such as holidays, weather and thus, they use the neural gas clustering to separate the data, before the data thread method is applied. This perfectly matches our idea of considering further information about the circumstances in a city. However, our approach considers more detailed information about specific districts rather than general information like holidays, which usually hold for an entire city. 

Similar to the approach presented by Tiedemann et al.~\cite{tiedemann}, H\"ossinger et al.~\cite{hoessinger} present a simple real-time occupancy model based on various pieces of data collected in the city of Vienna, Austria. An average day curve model was built using the ticket data from mobile phone parking, the counts of car parks, and the traffic flow volumes in the city. The data was collected following agreements with the respective mobile phone companies, through surveys and by accessing a dedicated traffic website, respectively. The predictions are valid for short-time spans and applicable to the above mentioned city.

Located in Spain (Barcelona), Caicedo et al.~\cite{caicedo} developed a methodology for predicting real-time parking space availability. The probabilistic algorithm consists of three subroutines: allocating simulated parking requests, estimating future departures, and forecasting parking availability. The forecast has been reported to improve as the system registers arrivals and departures. Similar to our work, Caicedo et al.~\cite{caicedo} take further factors into account, such as duration of stay and capacity of every operating parking facility.

Rajabioun and Ioannou~\cite{rajabioun2013} introduce an information system for parking guidance that enables communication between vehicles and the infrastructure. It proposes a prediction algorithm that forecasts the availability for parking locations based on real-time parking information. It takes into account parameters such as parking duration, arrival time, destination, pricing, walking distance, parking capacity, etc. Their algorithm uses a probabilistic density distribution model. The parking data was collected both from on-street parking meters and off-street garages in Los Angeles and San Francisco, USA. In a follow-up paper, Rajabioun and Ioannou~\cite{rajabioun2015} propose a multivariate autoregressive model that considers the temporal and spatial correlations of parking availability when making predictions. The authors hold that the model, which is integrated into a parking guidance and information system, recommends parking locations with high accuracy. 

In contrast to Rajabioun and Ioannou~\cite{rajabioun2013}, Chen~\cite{xchen} tackles the parking problem by aggregating parking lots. Their findings show that the prediction error of parking occupancy decreases by combining multiple parking lots. The trained models take into account factors such as day, time, event, distance, parking price, etc. The author evaluated multiple models, such as ARIMA, linear regression, support vector regression and feed forward neural network. It turns out that the neural networks algorithm scores the best when the model is evaluated on the SF\textit{park} data~\cite{sfpark_open_data}. The findings of Chen confirm our idea building models for smaller areas, such as one district and one parking lot. However, our work goes one step further by additionally transferring the trained model to districts where no data is available. 

Richter et al.~\cite{richter} address the parking prediction problem with the focus on model storage in vehicles. The authors train models of various granularity that would predict parking availability based on the information contained: a one-day model per road segment, a three-day model per road segment, and a seven-day model per road segment. Additionally, models based on regions and time intervals computed by clustering are tried out.
Hierarchical clustering with complete linkage is employed. The models are evaluated on street data from the SF\textit{park} project\cite{sfpark_open_data} and reach a prediction success rate of about 70\%. 

While all the presented approaches tackle the problem of improving the parking situation in cities with different ideas and implementations, they fundamentally differ from our work. 
Some approaches match with our idea of adding additional information about the current circumstances in a city or by building models for smaller areas.
However, none of the approaches focuses on building a solution that can be ported to other cities. 
As opposed to this, our presented approach uses a public pre-defined ontology and data in RDF format as input in order to calculate the prediction models and similarity measures. 
Further, none of the presented approaches aims at training prediction models for small areas where data are available and transfer those models to other areas where no data is available. Our approach aims exactly at this goal for enabling a more accurate prediction in districts or streets where no parking data are available. 

\section{Selected Data Source}
To implement and evaluate our idea, we use the data from the SF\textit{park} project. This project was realized by the San Francisco Municipal Transportation Agency (SFMTA), the city agency that manages the city's transportation, which includes on-street parking~\cite{sfpark} \cite{sfpark_evaluation}. The SFMTA establishes parking rates for on-street parking meters. Before the project started, parking rates were the same all day, every day, independent of the parking demand. By implementing a demand responsive pricing scheme, parking availability improved dramatically. 
%The facts listed in \autoref{tab:sfpark_results} show the improvements on parking after the project completed.
%
%\begin{table*}
%	\centering
%	\begin{tabular}{c}
%		\toprule
%		\begin{minipage}{0.7\textwidth}
%			\begin{itemize}
%            %	\itemsep 0.5em
%				\item the amount of time parking areas were too full decreased by 16\%
%				\item the amount of time to find a parking space decreased by 43\%
%				\item parking citations decreased by 23\%
%				\item traffic volume decreased by 8\% in the pilot areas
%				\item the average hourly rate was overall decreased by 11 cents, from \$2.69 to \$2.58
%				\item double-parking decreased by 22\%
%				\item there was a 30\% drop of greenhouse gas emissions per day (originally 7 cubic meters tons)
%				\item there was an increase in \$1.9M annual revenue, although raising revenue was not a goal of the project
%			\end{itemize}
%		\end{minipage}
%		\\ \bottomrule
%	\end{tabular}
%	\caption{The main results from the SF\textit{park} project}
%	\label{tab:sfpark_results}
%\end{table*}

In conducting the project, nine pilot areas were chosen for monitoring. Out of these areas, seven were selected to have new pricing policies, while two were control areas. The number of metered spaces used was 6000, which amounts for 25\% of the city's total. The meters allow rates to be deployed remotely and they transmit data to a central server through a wireless connection.

The data was collected using parking sensors. These provided the central server with the information needed to calculate the demand-responsive parking rates and provided real-time parking availability information. A parking sensor is a magnetometer that detects changes in the earth's electromagnetic field. A total of 11700 sensors were deployed, resulting in 8000 spaces that were equipped with one or two sensors. The sensors delivered valid data from April, 2011 to December, 2013. The sensors can suffer from environmental noise, such as electromagnetic interference, early battery degradation or street construction. 

SF\textit{park} made available real-time information on parking rates and parking occupancy through a smart phone application. The SF\textit{park} project and its success played an important role when choosing to base our project on it.

\section{Concept}
For implementing our approach, we extract parking data from SF\textit{park}. In addition, we collect city data from various sources (cf. Section \ref{sec:citydata}). To ensure that our approach will be compatible with data available in other cities, we annotate our data using ontologies from the CityPulse project~\cite{city_pulse} and store them in RDF format. Afterwards, we merge the data sets and perform a clustering process. Next, we define the parking profile by introducing two similarity functions: \textit{cosine similarity} and \textit{earth mover's distance}.
Finally, we explain the machine learning training process and define the estimations for clusters without parking data.

%\begin{figure}
%	\centering
%	\fbox{\includegraphics[width=0.45\textwidth]{graphics/concept_overview}}
%	\caption{Concept Visualization}
%	\label{realization:concept_overview}
%\end{figure}

\subsection{Parking Data}
We consider the following types of data as parking data: \textit{parking occupancy} contains information on the availability of parking spaces; \textit{traffic data} contains information regarding the city traffic, which is relevant for parking; \textit{weather data} contains weather information for the same area as for the parking problem; \textit{event data} contains event information which may have an impact on parking; \textit{parking revenue data} contains economic information on parking, whose relevance may influence parking prediction. \textit{fuel price data} contains prices of fuel in the region for which we build the models.
Each piece of data is geographically referenced by a \textit{location unit}, e.g., street block, district or city. 
An overview of the different properties available in the data set are shown in \Cref{tab:sfpark_data}.

\begin{table*}
\begin{tabular}{lp{6cm}lp{6cm}}	
	\toprule
Parking Occupancy & & Traffic & \\
\midrule
date and time & Recorded usually at full hours or in periodic time intervals & date and time & recorded usually at full hours or in periodic time intervals \\
parking capacity & The total number of parking spaces at the given location & traffic value & typically expressed as average traffic road occupancy, average vehicle count, median speed, or average speed of the traveling cars \\
parking price & The price of a ticket at the certain location and the given time in a given currency & & \\
parking occupancy & Expressed either as rate (subunitary fraction or percent) or in absolute numbers & & \\
	\midrule
	Events & & Weather & \\
	\midrule
	event name class & the name of the event and its class (road closure, rise of parking demand) & temperature & may be current temperatures or maximum and minimum values per day \\
	 & & 	precipitation & expressing the quantity of rain or snow for the corresponding time interval \\
	\midrule
Fuel Price & & Parking revenue & \\
\midrule	 
	 type of fuel & gasoline, diesel, etc. & payment type & the way the driver opted to pay for parking, e.g., cash, credit card, etc. \\
	 
	 price per unit & provided as the price per liter or per gallon. & payed amount & the amount in US dollars, Euro or other currency\\
	 
	\bottomrule
\end{tabular}

	\caption{An overview of the properties available in the data used from the SFpark project. 
		Each of these data types also has the location unit id, as well as the date and time (interval) when it occurred or was measured. 
		In some cases, the location is a somewhat larger or smaller area as the unit. The time information is provided in different granularities (e.g., per minute, per hour, per day, etc. ).}
	\label{tab:sfpark_data}
\end{table*}

\subsection{City Data}
\label{sec:citydata}
We established that city data reflects parking demand in a city area. We obtain it by collecting public amenity information as provided by OpenSteetMap\footnote{\url{https://www.openstreetmap.org} The maps used in this article are \textcopyright OpenStreetMap contributors}. The OSM data is available as shapefiles containing geometries such as points, polylines and polygons. We extract the \textit{points of interest} (POIs). A POI contains an \textit{amenity} attribute indicating the public service located at this position as it was annotated by the OSM users (cf. \Cref{fig:pois}).

\begin{figure}[!ht]
	\centering
	\includegraphics[width=0.5\textwidth]{graphics/cafes_restaurants_banks_larger.png}
	\caption{A map indicating public amenities (cafes, restaurants, banks) found at points of interest in OSM.}
	\label{fig:pois}
\end{figure}

The amenity information accounts for the times of parking (i.e., morning, day, night, etc.) and, up to some degree, for the duration of parking. An example of a service indicating this is Google Maps.
It displays typical \textit{visiting duration} values and popularity of the place for specific points in time. The average values are based on the users' smart phone GPS sensors (cf. \Cref{fig:visit_duration}). To obtain the duration values, we manually extract information from Google Maps. The duration information is aggregated by Google using a crowdsourcing approach. 

\begin{figure}[!ht]
	\centering
	\includegraphics[width=0.5\textwidth]{graphics/google_visit_duration.png}
	\caption{An example of visiting duration information found on Google Maps.}
	\label{fig:visit_duration}
\end{figure}

\subsection{RDF Annotation}
We emphasized that our approach should be relevant for any city that wants to solve its parking problem. Thus, all input data used in the present approach is in RDF format, in order to establish a common format that can be used for other cases.
Since the actual parking and city data is only available as raw values, we need to annotate it as RDF in the first place.
The default process involves the extraction of data, which is afterwards available for further processing. To annotate the city and parking data, we use Apache Jena. As underlying ontologies, we reuse those created as part of the CityPulse project~\cite{city_pulse}. Afterwards, we can easily extract the data in a well-defined format using SPARQL queries. 

\subsection{Merging City and Park Data}
In order to combine the parking and city data, both sets of data require a common location unit. 
The parking location units are provided together alongside the various types of parking data. 
The city data, on the other hand, references POI geometries, which are points expressed in a particular reference system, which differs from the one of the parking locations.
Therefore, after establishing the coordinate systems of both geometries, we define a \textit{merge distance} that matches a parking space to a public amenity. 

The merge distance can be intuitively understood as the radius around a public amenity. It is defined to represent the parking area that is relevant for a particular public amenity, or, more straightforward, the walking distance from the parked car to, e.g., the restaurant, the office, the bank, etc. Concrete instances of the merging distance can be found in \Cref{evaluation:merging_parking_city_data}.

\subsection{Clustering}
\label{concept:clustering}
In a realistic scenario, the available parking data does not cover the whole city surface. In fact, it is a fraction of it. Therefore, we first separate the area \textit{with} parking data from the area \textit{without} parking data. Based on this initial split, we perform clustering to further separate these regions into smaller areas. By splitting into city areas, we are making sure that smaller regions lead to more representative parking profiles and therefore parking estimations. 

As we want an exclusively location-based separation, we may employ K-Means, DBSCAN or OPTICS to cluster the city areas. The distance is calculated between (latitude, longitude)-pairs of location unit coordinates corresponding to one parking unit. There are two clustering processes executed, one for the city area \textit{with} parking data, another one for the city area \textit{without} parking data. The number of clusters chosen in each area is kept proportional to the number of total location units that each city area contains. Since having control over the number of clusters is the goal here, we choose to use K-Means, where we provide the number of expected clusters as input. More details on the concrete value of $k$ and an overview about the clusters can be found in Section \ref{evaluation:clustering}.

\subsection{Similarity Functions}
To calculate the similarity of city areas, we use \textit{cosine similarity} and \textit{earth mover's distance}. For this, we use two representations of city areas: \textit{cluster vectors} and \textit{cluster Gaussians}. As data, we use the city data described in Section \ref{sec:citydata}.

\subsubsection{Cosine Similarity}
\label{realization:vectors}
To form the cluster vectors, we first divide all amenities into categories $Cat_1, Cat_2, ..., Cat_n$.
The criteria for division will be their average visiting duration.
For example, a short duration category of up to 30 minutes, a medium duration between 31 and 90 minutes and a large duration of above 90 minutes stay.
Each cluster gets represented by an $n$-dimensional vector, whose components correspond to the amenity categories.
The magnitude of component $i$ is equal to the number of amenities of category $Cat_i$ that can be found in that particular cluster.
Compare \Cref{fig:cluster_vector} for a general representation.

\begin{figure}[!ht]
	\centering
	\includestandalone[width=0.4\textwidth]{graphics/cluster_vector}
	\caption{An example of a cluster vector for three categories.}
	\label{fig:cluster_vector}
\end{figure}
\label{realization:cosine_similarity}
The cosine similarity between two vectors is defined as the cosine of the angle between the two vectors:

\begin{equation}
cos(\theta)=\frac{A\cdot B}{{\lVert}A{\rVert}       
_2{\lVert}B{\rVert}_2}=\frac{\sum_{i=1}^n{A_iB_i}}{\sqrt{\sum_{i=1}^n{A_i^2}}\sqrt{\sum_{i=1}^n{B_i^2}}}
\end{equation}
where $A_i$ and $B_i$ are the components of vector A, respective B. 

Unlike the earth mover's distance, the cosine similarity implementation uses the direct mathematical formula by plugging in the magnitudes of the respective vector components.

\subsubsection{Earth Mover's Distance}
\label{realization:gaussians}

A cluster Gaussian is a \textit{kernel density estimation} among amenity probability distributions.
In turn, an amenity probability distribution is represented as \textit{Gaussian kernel}.
To construct a cluster Gaussian, we first collect the average visiting duration and standard deviation for the individual amenities.
A cluster that contains one amenity $A$ is represented as a Gaussian curve, i.e., normal probability distribution.
The curve's center is at the average duration of the amenity $A$ and its standard deviation is the one of the amenity.
When $n$ amenities $A$ exist in the cluster, the representation will be an $A$ curve multiplied $n$ times.
Multiple amenities, each appearing multiple times, will result in a curve that is the linear combination of the individual representations of the amenities as normal distribution curves.
Compare \Cref{fig:gaussian} for a visualization of the summing process.

\begin{equation}
EMD(\mathcal{C}_i) = \sum_{j=1}^{|amenities|} K_{ij} \times A_j
\end{equation}

$$\forall i \in \{1,..|clusters|\} \text{ and } \forall j \in \{1,..|amenities|\}$$

where $A_j$ is an amenity that appears $K_{ij}$ times in the cluster $\mathcal{C}_i$.

\begin{figure}[!ht]
	\centering
	\includegraphics[width=0.4\textwidth]{graphics/emd_gaussian_addition3.png}
	\caption{The summing of Gaussians resulting in a cluster Gaussian.}
	\label{fig:gaussian}
\end{figure}

The earth mover's distance (EMD) is a measure used in statistics that roughly expresses the difference between position and magnitude of two curves.
It is best explained by regarding the curves as the hull of earth piles.
For two separate earth piles, EMD computes the minimum effort of rearranging a pile so that the shape of the other pile is obtained.
Moving P particles over a distance D is equal to the effort $P \times D$.
A prerequisite for this operation is that the two piles need to contain the same quantity of earth.

More rigorously, the earth mover's distance is better known in mathematics under the name Wasserstein Metric.
Given two normal distributions $\mu_1=\mathcal{N}(m_1,C_1)$ and $\mu_2=\mathcal{N}(m_2,C_2)$, where $m_1$ and $m_2 \in \mathbb{R}^{n}$ are their respective expected values and $C_1$ and $C_2 \in \mathbb{R}^{n\times n}$.
Then, the 2-Wasserstein distance between $\mu_1$ and $\mu_2$ is:

\begin{equation}
W_2(\mu_1,\mu_2)^2={\lVert}m_1-m_2{\rVert}^2_2+trace(C_1+C_2-2(C_2^{1/2}C_1C_2^{1/2})^{1/2})
\end{equation}

In practice, we will not apply the Wasserstein metric directly, but rather resort to some levels of discretization.
First off, a number of so-called bins is determined.
Each bin represents a unit on the $X$ axis, the same on which the visiting duration is expressed.
We will take a number of buckets equal to the maximum amenity mean and add $3\times$ the largest standard deviation to it, as it is known that within $3\times$ standard deviation on both sides of the mean over 99\% of the Gaussian sum is covered.
Moreover, an offset on the $X$-axis equal to $3\times$ the maximum standard deviation is used.
This way, we are sure the landscape of summed Gaussians will easily fit into the number of bins.

Notice that EMD is applicable only when the sum under both Gaussian curves is equal.
Therefore, all cluster Gaussians will get normalized before EMD is computed.

\subsection{Machine Learning Models}
\label{realization:machine_learning_models}
The prediction of parking occupancy is realized using machine learning.
We choose to explore this methodology, following the solid results machine learning models have delivered for the various smart parking settings investigated in \Cref{sec:relwork}. A machine learning model $\mathcal{M}$ will be trained for every cluster \textit{with} parking data.

The training data \textit{features} are composed of the parking data previously enumerated. We aggregate feature values around the location unit id, as on the cluster level this is irrelevant. The occupancy rate is set as the target variable. The model training and evaluation is performed in Python via the \textit{scikit-learn} library.

During the training phase, we evaluate different machine learning approaches ranging from simple decision trees over random forests to support vector machines and gradient boosting. In addition, we make use of grid search to determine the best model parameters for the current approach. As error metric, we use root mean square error and performed a ten-fold cross-validation. Furthermore, a model is evaluated on the other clusters with parking occupancy data.

\subsection{Parking Occupancy Estimations}
\label{realization:parking_occupancy_estimations}
Once all models $\mathcal{M}$ have been built for the clusters \textit{with} parking data, making estimations on parking occupancy in these areas is straightforward. However, we want to apply these models, on the clusters that are missing parking data. We derive the \textit{estimation interval} for cluster $\mathcal{C}_{wout}^j$ based on the model of cluster $\mathcal{C}_{with}^i$ as follows.

For cosine similarity:
\begin{equation}
E(\mathcal{C}_{with}^i,\mathcal{C}_{wout}^j) = [\mathcal{M}(\mathcal{C}_{with}^i) - (1 - sim_{ij}), \text{    } \mathcal{M}(\mathcal{C}_{with}^i) + (1 - sim_{ij})]
\end{equation}
$$\text{where } sim_{ij} = sim(\mathcal{C}_{with}^i,\mathcal{C}_{wout}^j) \in [0,1]$$

For earth mover's distance:
\begin{equation}
E(\mathcal{C}_{with}^i,\mathcal{C}_{wout}^j) = [\mathcal{M}(\mathcal{C}_{with}^i) - emd_{ij},   \text{    }\mathcal{M}(\mathcal{C}_{with}^i) + emd_{ij}]
\end{equation}
$$\text{where } emd_{ij} = emd(\mathcal{C}_{with}^i,\mathcal{C}_{wout}^j) \in [0,1]$$

$$\forall i \in \{0,...,|\mathcal{C}_{with}|-1\} \text{ and } \forall j \in \{0,...,|\mathcal{C}_{wout}|-1\}$$.

$X$ is a parking data record containing feature values.
The result is an \textit{estimation interval} that ``stretches'' the punctual estimation into an interval depending on the similarity value.
The lower the similarity value is, the larger the length of the resulting estimation interval will be.

Notice that $X$ should be valid for both $\mathcal{C}_{with}^i$ and $\mathcal{C}_{wout}^j$. The averaged values used for features related to the location unit id will be transferred as they are similar to those of the target cluster $\mathcal{C}_{wout}^j$.

Furthermore, we define an \textit{estimation intersection interval}, whose purpose is to narrow down the computed estimation interval.
An estimation intersection interval for the clusters $\mathcal{C}_{with}^i$ and $\mathcal{C}_{wout}^j$ is computed by intersecting the \textit{estimation intervals} that have a better similarity among the clusters with data $\mathcal{C}_{with}^{0}, ..., \mathcal{C}_{with}^{i-1}$ and the same cluster without data $\mathcal{C}_{wout}^j$.

\begin{equation}
EII(\mathcal{C}_{with}^i,\mathcal{C}_{wout}^j) = \bigcap_{k=0}^{i-1} EI(\mathcal{C}_{with}^k,\mathcal{C}_{wout}^j) \\
\end{equation}

where
\begin{equation}
sim(\mathcal{C}_{with}^k,\mathcal{C}_{wout}^j) < sim(\mathcal{C}_{with}^i,\mathcal{C}_{wout}^j), k \in \{0,..,i - 1\} \text{ for EMD}\\
\end{equation}
\begin{equation}
sim(\mathcal{C}_{with}^k,\mathcal{C}_{wout}^j) > sim(\mathcal{C}_{with}^i,\mathcal{C}_{wout}^j), k \in \{0,..,i - 1\} \text{ for cosine} 
\end{equation}

$$\forall i \in \{0,...,|\mathcal{C}_{with}|-1\} \text{ and } \forall j \in \{0,...,|\mathcal{C}_{wout}|-1\}$$.

\section{Evaluation}
For evaluating our approach, we require parking and city data. As parking data, we use those from the SF\textit{park} project and determine the data sets that are relevant for our purposes. As city data, we take OpenStreetMap data from San Francisco and obtain the available public amenity information. Google Places provides the visiting duration values for the amenities. Based on these data sets, we determine relevant values for the \textit{merge distance}. Since we cannot evaluate the performance of our approach using clusters \textit{without} data, we evaluated the performance on clusters for which data were available. Therefore, we first calculated the similarity score between a cluster $c$ and all other clusters. Afterwards, we calculated the estimation errors when applying the model of cluster $c$ to all other clusters.

\subsection{SF\textit{park} Parking Data}
\label{evaluation:sfpark}
The SF\textit{park} data are visualized in \Cref{fig:before_clustering} using a built Leaflet application.
The actual SF\textit{park} data has some particularities.
While the \textit{occupancy data} is provided with reference to \textit{blocks} as location units, all the other data sets use different location units.
For the traffic and events data sets, the location units are street names.
For parking revenue, they are districts.
In case of weather and fuel price, the location reference is valid for the whole city of San Francisco. 

\begin{figure}[!ht]
	\centering
	\includegraphics[width=0.5\textwidth]{graphics/initial_view_before_clusteringV7.png}
	\caption{The blocks accounted in SF\textit{park}. The light blue ones are blocks \textit{without} parking data, the light red ones are \textit{with} parking data.}
	\label{fig:before_clustering}
\end{figure}

\subsection{OpenStreetMap for San Francisco}
\label{evaluation:osm_for_sf}
Following the selection of SF\textit{park} data as parking data, the city data is found in the corresponding OpenStreetMap layer for San Francisco.
The actual public amenity information collected from POIs is listed in \Cref{tab:amenities_list}.

\begin{table}[!ht]
	\scriptsize
	\begin{tabular}{ | l  l  l  l | }
		\hline
		arts\_centre & dojo & marketplace & shelter \\
		bank & embassy & music\_rehearsal\_place & shop \\
		bar & fast\_food & music\_school & spa \\
		biergarten & grocery & nightclub & stripclub \\
		bureau\_de\_change & gym & pet\_grooming\_shop & studio \\
		cafe & hookah\_lounge & pharmacy & training \\
		clinic & ice\_cream & police & veterinary \\
		clothes\_store & karaoke & post\_office & vintage\_and\_modern\_resale \\
		community\_centre & lan\_gaming\_centre & pub & \\
		dentist & laundry & restaurant & \\
		doctors & library & salon & \\
		\hline
	\end{tabular}
	\caption{List of all OSM amenities found in the SF\textit{park} blocks.}
	\label{tab:amenities_list}
\end{table}

\subsection{Merging Parking and City Data}
\label{evaluation:merging_parking_city_data}
In case of SF\textit{park}, the blocks are given in latitude and longitude.
In OpenStreetMap, the geometry is set to EPSG 4326.
With both systems using the same reference, we can therefore set a \textit{merge distance}.
The distance $d$ should express the impact that a POI $P$ has on the block $B$, when $dist(P, B) = d$. For instance, it expresses the impact of the parking demand that a restaurant induces on a parking block situated at $d$ meters away.
We assign to it distances of 100m, 200m, and 400m.

\subsection{Clustering}
\label{evaluation:clustering}
As established in \Cref{concept:clustering}, we apply K-Means to cluster the city areas.
In the evaluation, we will refer to the number of clusters \textit{with} parking data as \textit{the number of clusters}.
The area without parking data is going to be split into a proportional number of clusters, as the sizes of clusters should be kept roughly equal for both sides.
It turns out that the proportion is approximately 2.6, following the division between the total number of blocks from each group.
We have chosen two numbers of clusters to run the evaluation, namely 8 clusters and 16 clusters.
The area without parking data will therefore have 20 and 41 clusters, respectively. 

After running the K-Means clustering process, the Leaflet application map reveals the individual clusters by highlighting them on mouse-over.
The clusters \textit{with} parking data will turn dark red, while the clusters \textit{without} parking data will appear in dark blue (cf. \autoref{fig:highlighted_collage}). 

\begin{figure}[!ht]
	\centering
	\includegraphics[width=0.5\textwidth]{graphics/highlighted_collage.png}
	\caption{Highlighted cluster \textit{with} parking data on the left side and a cluster \textit{without} parking data on the right side.}
	\label{fig:highlighted_collage}
\end{figure}

The resulting aggregated blocks is worth taking into account when training the machine learning models, as these will average over pieces of information contained in individual blocks. 

\subsection{Similarity Functions}
\label{evaluation:urban_measure}
Before computing \textit{cluster vectors} and \textit{cluster Gaussians}, we will establish the visiting duration in every amenity.
For this, we use information gathered from Google Places available via Google Maps\footnote{http://maps.google.com}.

We manually collected information from 470 places in San Francisco, for which a maximum duration of stay was provided (the minimum duration is not always given, as indicated earlier).
The data was obtained by manually navigating to every business place and writing the duration visit information in a spreadsheet.
This piece of information is not accessible yet via the Google Places API\footnote{Google Feature Request: \url{https://issuetracker.google.com/issues/35827350}}.
The results are shown in \autoref{tab:amenities_google_places} and the numbers are given in minutes and have been rounded to the nearest integer. We have included only amenities for which at least two stay duration sources were found. 

\begin{table*}[!ht]
	\footnotesize
	\begin{tabular}{ | l | c | c | c || l | c | c | c |}
		\hline		
		\textbf{amenity name} & \textbf{mean} & \textbf{stdev} & \textbf{cat} & \textbf{amenity name} & \textbf{mean} & \textbf{stdev} & \textbf{cat} \\ \hline
		arts\_centre  & 110 & 37 & 3 & laundry  & 78 & 16 & 2 \\ \hline
		bank  & 42 & 65 & 2 &  library  & 83 & 13 & 2 \\ \hline
		bar  & 121 & 38 & 3 &  music\_school  & 120 & 30 & 3 \\ \hline
		cafe  & 76 & 39 & 2 &  nightclub  & 189 & 20 & 3 \\ \hline
		clinic  & 100 & 29 & 3 &  pharmacy  & 25 & 20 & 1 \\ \hline
		clothes\_store  & 41 & 37 & 2 &  post\_office  & 16 & 2 & 1 \\ \hline
		community\_centre  & 119 & 40 & 3 &  pub  & 135 & 21 & 3 \\ \hline
		dentist  & 104 & 35 & 3 &  restaurant  & 135 & 32 & 3 \\ \hline
		doctors  & 60 & 42 & 2 &  salon  & 141 & 53 & 3 \\ \hline
		embassy  & 75 & 24 & 2 &  shelter  & 90 & 0 & 2 \\ \hline
		fast\_food  & 31 & 15 & 2 &  shop  & 43 & 21 & 2 \\ \hline
		grocery  & 20 & 10 & 1 &  spa  & 161 & 54 & 3 \\ \hline
		gym  & 100 & 22 & 3 &  stripclub  & 140 & 46 & 3 \\ \hline
		hookah\_lounge  & 130 & 17 & 3 &  studio  & 60 & 0 & 2 \\ \hline
		ice\_cream  & 23 & 7 & 1 &  veterinary  & 67 & 29 & 2 \\ \hline
		karaoke  & 188 & 15 & 3 & {\scriptsize vintage\_modern\_resale}  & 38 & 32 & 2 \\ \hline
	\end{tabular}
	\caption{All amenities listed with their corresponding mean visiting duration (in minutes) and standard deviation, as collected from Google Places.
The assigned category for cluster vectors is included.}
	\label{tab:amenities_google_places}
\end{table*}

Alongside this information, we need the amenity categories in order to derive the \textit{cluster vectors}.
As defined in \Cref{realization:vectors}, the categories are based on the visiting duration mean.
We split them in three categories: under half an hour, 31 to 90 minutes and more than 1.5 hours. 
The assigned partitions for every amenity are shown in \Cref{tab:amenities_google_places}. 

The calculation of \textit{cluster Gaussians} relies on both the mean and standard deviation of the amenity visiting duration, as defined in \Cref{realization:gaussians}.

\subsection{Model Training and Evaluation for Clusters \emph{with} Parking Data}
\label{evaluation:model_training}
We use four methods to train models for the clusters \textit{with} parking data: \textit{decision trees}, \textit{support vector machines}, \textit{multilayer perceptrons}, \textit{gradient boosted trees}. As training data, the SF\textit{park} \textit{occupancy data} is used with \textit{street blocks} as location unit. It turns out that training on the additional SF\textit{park} data, i.e., traffic and events, encounters some problems. 

The \textit{traffic data} do not share the same location unit with the parking occupancy's street block. However, aggregating traffic data on the district level, which is available for the occupancy data as well, does not provide an additional value to the training. For the SF\textit{park} \textit{events data} we encounter the same problem as for the traffic data: the location unit does not match the block.
In fact, the events are marked for streets, whose association to blocks is not determinable. \textit{Parking revenue data} is provided for districts, which again are too general to make a difference in training.
Finally, \textit{weather data} and \textit{fuel data} are given per city, hence making even less an impact to improve the model.

{\color{green}
The evaluation here consists in comparing the test-errors of cluster models with the independently-computed similarity values. More specifically, a \textit{source} cluster's model will tested on a \textit{target} cluster. The resulting error (measured as root mean square) will be compared to the similarity (cosine or EMD) between the \textit{source} and the \textit{target} clusters.  
}

\subsection{Aggregating training data}
\label{evaluation:aggregating_training_data}
As indicated in \Cref{realization:machine_learning_models}, the training data is aggregated across all blocks so that it can be applied later on other clusters. The averaging is performed per timestamp, i.e., if multiple blocks have an occupancy record for the same time and block, the occupancy rate will be averaged for both of these. Features such as \textit{price} and \textit{parking capacity per block} are averaged as well. This means that the original collection of data records shrinks{\color{green}, which should improve the training time. In \autoref{tab:models_training_points}, the expansion/shrinking rate is shown for various number of clusters.}

%\begin{table}[!ht]
%	\setlength\extrarowheight{5pt}
%	\centering
%	\footnotesize
%	\begin{tabular}{| c | S[table-format=5.0] | S[table-format=6] | S[table-format=2.1] |}
%		\hline
%		\textbf{Cluster ID} & \textbf{Data Points} & \textbf{Occupancy Points} & \textbf{\begin{tabular}{@{}c@{}}Blocks\\per Timestamp\end{tabular}} \\ \hline
%		0 & 9879 & 120320 & 12.2 \\ \hline
%		1 & 12387 & 203728 & 16.4 \\ \hline
%		2 & 8713 & 61839 & 7.1 \\ \hline
%		3 & 6134 & 22371 & 3.6 \\ \hline
%		4 & 9586 & 110463 & 11.5 \\ \hline
%		5 & 9112 & 87316 & 9.6 \\ \hline
%		6 & 10244 & 118096 & 11.5 \\ \hline
%		7 & 9500 & 115588 & 12.2 \\ \hline
%		8 & 9051 & 112245 & 12.4 \\ \hline
%		9 & 8713 & 76230 & 8.7 \\ \hline
%		\textbf{Average}	& 9332 & 102820 & 10.5 \\ \hline
%	\end{tabular}
%	\captionsetup{justification=centering}
%	\caption{Number of training points per model alongside the initial occupancy points within the containing blocks.}
%	\label{tab:models_training_points}
%\end{table}

\begin{table}[!ht]
	{\color{orange}
	\setlength\extrarowheight{5pt}
	\centering
	\footnotesize
	\begin{tabular}{| c | S[table-format=5.0] | S[table-format=6] | S[table-format=2.1] |}
		\hline
		{cluster size} & {aggregated datapoints} & {all datapoints} & {shrinking/expansion rate} \\ \hline
		8 &	9741 & 128525 &	12.3 \\ \hline
		16 & 8409 &	73332 &	8.3 \\ \hline
		32 & 6257 &	29355 &	4.6 \\ \hline
	\end{tabular}
	\captionsetup{justification=centering}
	\caption{\color{orange} Number of datapoints aggregated per timestamp vs. all datapoints alongside the shrinking rate; for 8, 16 and 32 clusters; values have been averaged across clusters}
	\label{tab:models_training_points}}
\end{table}

%\subsection{Model Evaluation for Clusters \textit{with} Parking Data}
\label{evaluation:training_testing_errors}
In \Cref{fig:cwith} a screenshot of the application showing a sample of the results is illustrated. \Cref{fig:cwith_table} displays the presented table in more detail.

\begin{figure}[!ht]
	\centering
	\includegraphics[width=0.5\textwidth]{graphics/cwith_source_dt_cosine.png}
	\caption{Selected cluster \textit{with} parking data and the pop-up table in the Leaflet application.}
	\label{fig:cwith}
\end{figure}

\begin{figure*}[!ht]
	\centering
	\includegraphics[width=0.7\textwidth]{graphics/cwith_source_dt_cosine_table.png}
	\caption{The pop-up table for the Leaflet application view of  \Cref{fig:cwith}.}
	\label{fig:cwith_table}
\end{figure*}

\subsection{Best Model Method}
\label{evaluation:best_model}
Models were trained using four methods: decision trees, support vector machines, multilayer perceptrons, gradient boosted trees. \autoref{evaluation:best_model_method} shows the distribution of best machine learning methods in case of 8 and 16 clusters.
The values were obtained by summing up the number of times a method produced the least estimation error, i.e., RMSE, among the four methods for all combinations of clusters with parking data $(\mathcal{C}_{source}, \mathcal{C}_{target})$.
Extreme gradient boosting claims the first spot in both cases.

\begin{table}[!ht]
	\centering
	\small
	\setlength\extrarowheight{5pt}
	\begin{tabular}{ | c | c | c | c | c |}
		\hline
		& \textbf{dt} & \textbf{svm} & \textbf{mlp} & \textbf{xgb} \\ \hline
		\textbf{8 clusters} & 24.6\% & 17.5\% & 12.3\% & 45.6\% \\ \hline
		\textbf{16 clusters} & 14.6\% & 13.8\% & 13.8\% & 57.9\% \\ \hline
	\end{tabular}
	\caption{The proportion of best models among decision trees, support vector machine, multilayer perceptron and gradient boosting  measured as RMSE when applied on all pairs of clusters}
	\label{evaluation:best_model_method}
\end{table}

\subsection{Clustered- vs. Total Models}
\label{small_vs_large}
One assumption of our approach is that models originating from smaller clusters are better at predicting occupancy than models trained with the entire city area.
We have compared the two types of models during our tests.
For each target cluster $\mathcal{C}_{target}$, we determine the source cluster $\mathcal{C}_{source}$ whose model has the best estimation error when applied on $\mathcal{C}_{target}$.
We also train a model containing the entire city area with parking data $\mathcal{A}$ minus $\mathcal{C}_{target}$'s data and compute this model's estimation error on $\mathcal{C}_{target}$.
As we can observe from \autoref{evaluation:cluster_vs_total_8c}, in the case of 8 clusters, and in \autoref{evaluation:cluster_vs_total_16c} for 16 clusters, the cluster's models estimations are superior to the ones of the total model with very few exceptions.

\begin{table*}[!ht]
	\centering
	\scriptsize
	\setlength\extrarowheight{5pt}
	\begin{tabular}{ | c | c | c | c | c | c |}
		\hline
		$\mathcal{C}_{target}$ & $\mathcal{M}(\mathcal{A} \setminus \mathcal{C}_{target})$ & $error_{total}$ & $error_{cluster}$ & $\mathcal{M}(\mathcal{C}_{source})$ & $\mathcal{C}_{source}$ \\ \hline
		0 & xgb & 18.20 & 16.10 & xgb & 6 \\ \hline
		1 & dt & 17.44 & 12.14 & xgb & 7 \\ \hline
		2 & xgb & 20.33 & 17.45 & svm & 5 \\ \hline
		3 &	xgb & 17.59 & 13.35 & xgb &	1 \\ \hline
		4 & dt & 17.49 & 17.30 & xgb & 6 \\ \hline
		5 & xgb & 18.44 & 16.08 & xgb &	2 \\ \hline
		6 & xgb & 16.00 & 15.92 & svm &	0 \\ \hline
		7 & dt & 16.38 & 10.87 & xgb & 3 \\ \hline
	\end{tabular}
	\caption{Comparison between the estimations of the total models versus the ones of clustered models, in case the city is split into 8 clusters. Errors are expressed as RMSE.}
	\label{evaluation:cluster_vs_total_8c}
\end{table*}

\begin{table*}[!ht]
	\centering
	\scriptsize
	\setlength\extrarowheight{5pt}
	\begin{tabular}{ | c | c | c | c | c | c |}
		\hline
		$\mathcal{C}_{target}$ & $\mathcal{M}(\mathcal{A} \setminus \mathcal{C}_{target})$ & $error_{total}$ & $error_{cluster}$ & $\mathcal{M}(\mathcal{C}_{source})$ & $\mathcal{C}_{source}$ \\ \hline
		0 & mlp & 19.53 & 13.40 & xgb &	15 \\ \hline
		1 & xgb & 17.82 & 17.18 & xgb &	7 \\ \hline
		2 &	xgb & 20.79 & 17.97 & svm &	6 \\ \hline
		3 & xgb & 16.44 & 13.25 & xgb &	0 \\ \hline
		4 & xgb & 17.58 & 16.40 & xgb & 8 \\ \hline
		5 & dt & 17.59 & 10.93 & xgb & 0 \\ \hline
		6 & xgb & 18.44 & 16.29 & xgb & 2 \\ \hline
		7 & xgb & 16.73 & 16.38 & xgb & 9 \\ \hline
		8 & xgb & 13.57 & 14.14 & xgb & 10 \\ \hline
		9 & xgb & 16.90 & 15.95 & xgb & 10 \\ \hline
		10 & xgb & 16.25 & 16.45 & xgb & 7 \\ \hline
		11 & mlp & 21.73 & 14.95 & xgb & 11 \\ \hline
		12 & xgb & 20.33 & 15.42 & xgb & 0 \\ \hline
		13 & dt & 14.52 & 11.39 & xgb & 15 \\ \hline
		14 & dt & 22.93 & 18.73 & svm & 6 \\ \hline
		15 & dt & 20.63 & 13.33 & xgb & 0 \\ \hline
	\end{tabular}
	\caption{Comparison between the estimations of the total model versus the ones of clustered models, in case the city is split into 16 clusters. Errors are expressed as RMSE.}
	\label{evaluation:cluster_vs_total_16c}
\end{table*}

\subsection{Similarity Values vs. Estimation Errors}
\label{evaluation:similarity_vs_estimation_sec}
The goal of our approach was to replace occupancy estimations for clusters where no parking data is available with estimations based on cluster similarity values.
Among clusters \textit{with} parking data, the real occupancy values are known.
This enables us to compute estimation errors for cluster models, which can then be correlated with the similarity values between clusters.
We use two correlation coefficients: the Pearson correlation coefficient and Spearman's rank correlation coefficient.

We have evaluated both cosine and EMD similarity values in configurations of 8 and respectively 16 clusters.
Additionally, we varied the \textit{merge distance} to see how the correlation behaves.
The similarity values are hence calculated for 100m, 200m, and 400m merge distance respectively.
In \autoref{evaluation:similarity_vs_estimation} the final results are shown.
For each correlation measure, the percent of similarity values were calculated that correlated positively, in case of EMD distance, or negatively, for cosine similarity, with the estimation errors.
The models taken were trained with gradient boosted trees. 

We notice that the cosine similarity achieves better results than EMD for the same testing configuration, peaking at 100\% negative correlation for 8 clusters and 100m merge distance.
Its average Pearson coefficient is $-0.55$, while the mean Spearman rank coefficient is $-0.49$.
EMD positively correlates the most for the same testing configuration, when the average Pearson coefficient is at $0.28$ and Spearman's rank coefficient equals $0.23$.
There is a clear descending trend in correlations, as the merge distance increases.  Also, the results for 8 clusters are superior to the ones when the city is split in 16 clusters.

\begin{table}[!ht]
	\centering
	\small
	%\setlength\extrarowheight{5pt}
	%\resizebox{\textwidth}{!}{
	\begin{tabular}{ | c | c | c | c | c | c | c | c | c |}
		\hline
		{} & \multicolumn{4}{c|}{8 clusters} \\ \hline
		{merge distance} & cosine & rank\_cosine & emd & rank\_emd \\ \hline
		100m & \textbf{100\%} & \textbf{100\%} & \textbf{87.5\%} & \textbf{75\%} \\ \hline
		200m & 75\% & 75\% & 75\% & 75\% \\ \hline
		400m & 62.5\% & 50\% & 75\% & 75\% \\ \hline
	\end{tabular}%}
	\vspace{3em}
	\begin{tabular}{ | c | c | c | c | c | }
		\hline
		{} & \multicolumn{4}{c|}{16 clusters} \\ \hline
		{merge distance} & cosine & rank\_cosine & emd & rank\_emd \\ \hline
		100m & 75\% & 75\% & 68.75\% & 62.5\% \\ \hline
		200m & 75\% & 75\% & 56.3\% & 56.3\% \\ \hline
		400m & 68.8\% & 68.8\% & 62.5\% & 62.5\% \\ \hline
	\end{tabular}
	
	\caption{Correlations between similarity values and model estimations errors for pairs of clusters \textit{with} parking data ($\mathcal{C}_{source}, \mathcal{C}_{target})$.
For cosine similarity, the proportions show the negative correlation, while for EMD, they express the positive correlation.
The Pearson coefficient and Spearman's rank coefficient were used. }
	\label{evaluation:similarity_vs_estimation}
\end{table}	

\subsection{Estimations for Clusters \textit{without} Parking Data}
\label{evaluation:estimations_cwout}
We apply the models trained on SF\textit{park} data on clusters \textit{without} parking data.
The testing data records are composed of values equal to the averages of the respective data types in all clusters \textit{with} parking data.
This is the case for \textit{parking price} and \textit{parking capacity}.
One piece of data that still needs to be provided so that the estimation is computed is the date and time.
For convenience, we choose the next day at the point when the user starts the model training. 
An example of the estimation is visualized \autoref{fig:cwout_table}.

\begin{figure*}[!ht]
	\centering
	\includegraphics[width=0.7\textwidth]{graphics/cwout_cosine_table.png}
	\caption{The pop-up table of a cluster without data.
Notice the drop-down list from which the time can be selected.}
	\label{fig:cwout_table}
\end{figure*}

{\color{green}
\section{Extensions}
\label{extensions}
%Up to this point it was our goal to show that the approach involving clustering and similarity improves upon the simple machine learning approach. 
In the following we present some extensions and variations that consolidate the approach presented, if not improve upon it. 

Firstly, in \autoref{extensions:entire_datapoints}) we investigate the results by skipping the aggregating step in machine learning training (recall \autoref{evaluation:aggregating_training_data}). Instead of averaging the datapoints over timestamp per cluster, we build the cluster models using the entire occupancy data.

Secondly, in \autoref{extensions:amenity_area} we use another amenity value on which of the similarity functions are applied (recall \autoref{extensions:amenity_area}). Instead of \textit{amenity time spent}, \textit{amenity area} will extracted and leveraged. 

Thirdly, in \autoref{extensions:machine_learning_better} we question whether the similarity function approach is the most efficient and transfer its purpose to the machine learning phrase (recall \autoref{extensions:machine_learning_better}). The model will receive absolute \textit{cosine} and \textit{emd Gaussian} values as additional features and its error will be compared to the previous models. 

%Furthermore, we added a configuration with 32 clusters on which we tested or hypotheses.

\subsection{Using all occupancy datapoints}
\label{extensions:entire_datapoints}
Recall that in \Cref{evaluation:model_training}, the training data for a cluster is aggregated per timestamp, i.e. the \textit{price}, \textit{capacity} and \textit{occupancy} attributes (see \autoref{extensions:aggregating_datapoints} for an example). The training phase was subsequently more time-consuming as it involved digesting a significantly larger dataset (see \autoref{tab:models_training_points} for the expansion/shrinking rates for various number of clusters). Among the resulting models, \textit{extreme gradient boosting} proved to performed the best in terms of test errors (as in the aggregated points case). Otherwise, the models ended up poorer compared to the models with averaged values in terms of training and test errors. (see \autoref{extensions:train_test_errors}). Correlating the occupancy results delivered by theses models with the unchanged similarity values results in generally inferior numbers to correlations based on model from aggregated datapoints. Apart from the ranked emd correlation for 8 and 16 clusters and the ranked cosine for 16 clusters, all other correlation measures are not improved upon (see \autoref{extensions:correlation_values}).

\begin{table*}
{\color{green}
\footnotesize
\begin{tabular}{  c : c  }
		\begin{tabular}{ | c | c | c | c | c |}
			\hline
			\textbf{block id} & \textbf{timestamp} & \textbf{price rate} & \textbf{total spots} & \textbf{occupied} \\ \hline
			902 & {2011-04-02 7:00:00} & 0 & 46 & 58 \\ \hline
			32800 & {2011-04-02 7:00:00} & 0 & 32 & 2 \\ \hline
			33005 & {2011-04-02 7:00:00} & 3 & 36 & 12 \\ \hline
			902 & {2011-04-02 8:00:00} & 2 & 46 & 54 \\ \hline
			32800 & {2011-04-02 8:00:00} & 4 & 32 & 5 \\ \hline
			33005 & {2011-04-02 8:00:00} & 3 & 36 & 22 \\ \hline
		\end{tabular}
 & 
		\begin{tabular}{ | c | c | c | c | c |}
			\hline
			\textbf{cluster id} & \textbf{timestamp} & \textbf{price rate} & \textbf{total spots} & \textbf{occupied} \\ \hline
			1 & {2011-04-02 10:00:00} & 1 & 34 & 26 \\ \hline
			1 & {2011-04-02 11:00:00} & 3 & 34 & 27 \\ \hline
		\end{tabular}
\end{tabular}}
\caption{\color{green} Example of aggregating datapoints; left-hand side are three blocks belonging to cluster 1 which are transformed into two entries by averaging \textit{price rate}, \textit{total spots} and \textit{occupied} attributes per timestamp (right-hand side)}
\label{extensions:aggregating_datapoints}
\end{table*}

\begin{table}[!ht]
	{\color{green}
	\centering
	\small
	%\setlength\extrarowheight{5pt}
	%\resizebox{\textwidth}{!}{
	\begin{tabular}{ | c | c | c | c | c | c | }
		\hline
		{cluster size} & datapoints & {training error} & {test error} \\ \hline
		8	&	aggregate &	12.92	&	20.13 \\ \hline
		8	&	all		&	19.41	&	26.86 \\ \hline
		16	&	aggregate	&	13.52	&	20.52 \\ \hline
		16	&	all		&	19.05	&	26.36 \\ \hline
		32	&	aggregate	&	14.59	&	21.67 \\ \hline
		32	&	all		&	18.54	&	27.50 \\ \hline
	\end{tabular}%}
	\caption{\color{green} Train and test error for the ML models build with all datapoints; the same values are shows by comparison for the models build on aggregate datapoints for 8, 16 and 32 clusters; all models above were build using extreme gradient boosting}
	\label{extensions:train_test_errors}}
\end{table}


\begin{table}[!ht]
	{\color{green}
	\centering
	\small
	%\setlength\extrarowheight{5pt}
	%\resizebox{\textwidth}{!}{
	\begin{tabular}{ | c | c | c | c | c | c | }
		\hline
		{cluster size} & datapoints & cosine & rank\_cosine & emd & rank\_emd \\ \hline
		8	&	aggregate	&	-0.47	&	-0.50	&	0.26	&	0.17 \\ \hline
		8	&	all		&	-0.41	&	-0.42	&	0.34	&	0.25 \\ \hline
		16	&	aggregate	&	-0.11	&	-0.11	&	0.14	&	0.10 \\ \hline
		16	&	all		&	-0.02	&	-0.14	&	0.13	&	0.12 \\ \hline
		32	&	aggregate	&	-0.13	&	-0.06	&	0.09	&	0.07 \\ \hline
		32	&	all		&	-0.01	&	-0.02	&	0.03	&	0.01 \\ \hline
	\end{tabular}%}
	\caption{\color{green} Resulting correlation values for ML models built using all datapoints alongside correlations of models based on aggregate datapoints for 8, 16 and 32 clusters; all models above were build using extreme gradient boosting}
	\label{extensions:correlation_values}}
\end{table}


\subsection{Amenity area as similarity basis}
\label{extensions:amenity_area}
Together with the similarity functions we considered \textit{timespent} as the basis for creating the urban profile (recall \autoref{evaluation:urban_measure}). However, there are other measures that reflect the parking demand corresponding towards an amenity, one of them being area of the particular amenity, which is available in OpenStreetMap. OSM provides a \textit{polygon layer} for a certain geographic bounding box, which contains information across all the surfaces in that region (recall \autoref{sec:citydata}). In extracting this information we had two options. 

Matching the amenities' POIs with the containing OSM polygon and then computing the polygon areas per amenity was the option tried first. This has several disadvantages: the relation POI : polygon is in practice by no means 1:1, i.e. many cases arose where multiple POIs were contained by the same polygon, in which case the area was split between them; a POI might also be on the edge of several polygons, in which case we have to either (arbitrarily) assign it to the first polygon or to all. The deciding factor against this option was, however, the high \textit{coefficient of variation} for the area values. 

The coefficient of variation (CV) is a measure of dispersion of a probability distribution and is defined as the ratio between the standard deviation and the mean of a sample (see \autoref{extensions:cv}). When calculating the coefficient of variation based on the matching of POI with the polygons, it came out $2.1$.

\begin{equation}
c_v = \frac{\sigma}{\mu} 
\label{extensions:cv}
\end{equation}

The other option was to use the \textit{amenity} attribute in the polygon layer for the region. We could avoid the cumbersome matching by leveraging solely the polygon layer and calculating the amenity area mean and its standard deviation (see \autoref{extensions:amenity_area_values}). On top of that, the coefficient of variation is $0.9$ in this case, significantly lower than before. Note that we have reduced the values by a factor of 20, as it turned out that the actual mean and standard deviation were large enough to make the emd Gaussian computation extremely slow. As the standard deviation is linear with regard to the mean, both mean and standard deviation values were reduced conveniently. 

Replacing the amenity area's key values in the similarity computation, i.e. category in cosine similarity, mean and standard deviation in earth mover's distance, we arrive at the following correlation values (see \autoref{extensions:correlation_amenity_area}). It is clear that the area did not lead to an improvement of the correlation values.

\begin{table*}[!ht]
	{\color{green}
	\footnotesize
	\begin{tabular}{ | l | c | c | c || l | c | c | c |}
		\hline		
		\textbf{amenity name} & \textbf{mean} & \textbf{stdev} & \textbf{cat} & \textbf{amenity name} & \textbf{mean} & \textbf{stdev} & \textbf{cat} \\ \hline
		arts\_centre & 68 & 60 & 2 & bank & 39 & 20 & 2 \\ \hline
		bar & 19 & 8 & 1 & bicycle\_parking & 8 & 7 & 1 \\ \hline
		biergarten & 11 & 12 & 1 & brokerage & 39 & 9 & 2 \\ \hline
		bus\_station & 588 & 737 & 3 & cafe & 17 & 10 & 1 \\ \hline
		car\_rental & 70 & 43 & 2 & car\_wash & 43 & 48 & 2 \\ \hline
		childcare & 101 & 130 & 3 & cinema & 75 & 43 & 2 \\ \hline
		clinic & 61 & 32 & 2 & community\_centre & 52 & 74 & 2 \\ \hline
		conference\_centre & 401 & 519 & 3 & courthouse & 459 & 201 & 3 \\ \hline
		dentist & 17 & 12 & 1 & doctors & 324 & 568 & 3 \\ \hline
		embassy & 68 & 38 & 2 & fast\_food & 25 & 24 & 1 \\ \hline
		fire\_station & 52 & 27 & 2 & fountain & 24 & 22 & 1 \\ \hline
		fuel & 25 & 27 & 1 & library & 102 & 124 & 3 \\ \hline
		marketplace & 325 & 228 & 3 & music\_rehearsal\_place & 33 & 15 & 1 \\ \hline
		nightclub & 32 & 9 & 1 & nursing\_home & 97 & 47 & 2 \\ \hline
		parking & 182 & 309 & 3 & pharmacy & 65 & 38 & 2 \\ \hline
		place\_of\_worship & 60 & 62 & 2 & police & 137 & 124 & 3 \\ \hline
		post\_office & 39 & 11 & 2 & pub & 25 & 25 & 1 \\ \hline
		public\_building & 280 & 236 & 3 & recycling & 28 & 20 & 1 \\ \hline
		restaurant & 22 & 16 & 1 & school & 740 & 1280 & 3 \\ \hline
		social\_centre & 30 & 21 & 1 & social\_facility & 356 & 801 & 3 \\ \hline
		stripclub & 50 & 10 & 2 & studio & 268 & 307 & 3 \\ \hline
		swimming\_pool & 16 & 9 & 1 & swingerclub & 27 & 4 & 1 \\ \hline
		theatre & 174 & 191 & 3 & toilets & 7 & 5 & 1 \\ \hline
		training & 72 & 94 & 2 & veterinary & 21 & 7 & 1 \\ \hline
	\end{tabular}
	\caption{\color{green} Amenity area values gathered from OMS polygon layer for the SF\textit{park} region; mean and standard deviation values were reduced by a 20x factor; categories are 0 - 35, 36 - 100, 100+}
	\label{extensions:amenity_area_values}}
\end{table*}

\begin{table*}[!ht]
	{\color{green}
	\centering
	\small
	%\setlength\extrarowheight{5pt}
	%\resizebox{\textwidth}{!}{
	\begin{tabular}{ | c | c | c | c | c | c | c | }
		\hline
		{cluster size} & {amenity type} & method & cosine & rank\_cosine & emd & rank\_emd \\ \hline
		8 & timespent & xgb & -0.47 & -0.50 & 0.26 & 0.17 \\ \hline
		8 & area & xgb & -0.20 & -0.18 & 0.14 & 0.22 \\ \hline
		16 & timespent & xgb & -0.11 & -0.11 & 0.14 & 0.10 \\ \hline
		16 & area & xgb & -0.05 & -0.01 & 0.05 & 0.03 \\ \hline
		32 & timespent & xgb & -0.13 & -0.06 & 0.09 & 0.07 \\ \hline
		32 & area & xgb & 0.08 & 0.06 & -0.05 & -0.02 \\ \hline
	\end{tabular}%}
	\caption{\color{green} The correlation results based on the amenity area values.}
	\label{extensions:correlation_amenity_area}}
\end{table*}

\subsection{Machine learning better than the similarity functions?}
\label{extensions:machine_learning_better}
An alternative to building urban measures and similarity functions is to let machine learning figure out the similarities by itself. One can simply add the city data as further training information for clusters. The purpose is to find better similarities by leveraging unknown patterns in the city data. Hence, features representing cosine and emd are added to the model, as follows: 
\begin{itemize}
	\item a feature corresponding to the k categories the amenities are split in, specifically the magnitudes of the vectors for each category;
	\item a feature corresponding to the emd Gaussian value for that cluster, specifically the area under the emd Gaussian.
\end{itemize}
The subsequently built machine learning models cannot however be formed on a single cluster, as the additional features would be the same for all datapoints, of course. Therefore, models on $n-1$ out of $n$ clusters will be build and tested on the remaining cluster (as it was done in the total models evaluation - recall \autoref{small_vs_large}). The resulting training and test errors are show in \autoref{extensions:extended_models_comparison}. (discussion)

\begin{table}[!ht]
	{\color{green}
	\footnotesize
	\begin{tabular}{ | c | c | c | c | }
		\hline		
		\textbf{cluster size}  & \textbf{model} & \textbf{training error avg} & \textbf{test error avg} \\ \hline
		8 & {xgb} & 17.90 & 18.01 \\ \hline
		8 & {xgb extended} & 17.46 & 19.08 \\ \hline
		8 & {dt} & 18.85 & 18.52 \\ \hline
		8 & {dt extended} & 19.84 & 19.46 \\ \hline
		%8 & {svm} & TBD & TBD \\ \hline
		%8 & {svm extended} & 20.15 & 23.62 \\ \hline
		%8 & {mlp} & TBD & TBD \\ \hline
		%8 & {mlp extended} & 54.62 & 203.22 \\ \hline
		16 & {xgb} & TBD & TBD \\ \hline
		16 & {xgb extended} & 17.63 & 17.02 \\ \hline
		16 & {dt} & TBD & TBD \\ \hline
		16 & {dt extended} & 18.77 & 17.81 \\ \hline
		%16 & {svm} & TBD & TBD \\ \hline
		%16 & {svm extended} & 22.52 & 23.49 \\ \hline
		%16 & {mlp} & TBD & TBD \\ \hline
		%16 & {mlp extended} & 22.53	& 19.36 \\ \hline
	\end{tabular}}
	\caption{\color{green} Models extended with cosine and emd features compared to previous models with regard to training- and testing errors; all models are total models}
	\label{extensions:extended_models_comparison}
\end{table}

\section{Further possible variations}
\label{conclusion:future_work}
} % \color{green}
To further investigate parking occupancy prediction given the assumptions in this work, there are several improvements or alternative approaches that can be realized.

\begin{enumerate}
	\item \textbf{Use other parking settings}.
	In the present work, several pieces of data could not be integrated because of merging issues, i.e., the location unit did not coincide with the occupancy data's block.
	Traffic, events, weather, etc. could improve estimation results and hence the final estimations for clusters without parking data.
	Other sources for parking occupancy data can be found for the cities of Cologne~\cite{cologne_data}, Zurich~\cite{zurich_data}, Santa Monica~\cite{santa_monica_data}.
	In Germany, Deutsche Bahn provides an API to obtain data from parking around train stations~\cite{dbbahn_data}.
	Data pertaining to street occupancy is, however, hard to find.
	At the time of writing, open data portals mostly provide the location of parking lots, parking meters, parking price and opening times, if applicable.  
	
	\item \textbf{Use more city data}.
	The parking profiles in the present work are relying on the public amenities from OpenStreetMap.
	OSM has great potential as a collaborative map service but it lacks many pieces of information that could be useful.
	Data such as opening hours would be interesting to include in the parking demand profile, which would then take into account the number of public amenities that are available at a certain point in time.
	Furthermore, the stay duration data collected for the present approach is currently limited.
	Adding more stay duration data may fine tune the emerging similarity values.
	Overall, more and finer city data, together with an appropriate representation and similarity function could eventually improve the occupancy estimations for clusters without parking data. 
	
	{\color{red}
	\item \textbf{Integrate city data in machine learning models}.
	An alternative to building urban measures and similarity functions is to let machine learning figure out the similarities by itself.
	One can add the city data as further training information for clusters.
	The models are then applied on clusters without parking data and return occupancy estimations.
	The difference here is that models will be built for all clusters, including the ones without parking data.
	This also has the disadvantage of not using most of the parking data for training.
	The benefit of finding better similarities by leveraging unknown patterns in the city data may, however, outweigh this drawback. 
	}
	
	\item \textbf{Apply semi-supervised machine learning}.
	Another relevant machine learning approach in this case is based on organizing the city areas as an undirected graph.
	The vertices represent the clusters with their respective occupancy data, while the edges between them are assigned similarity values.
	Initially, only a part of the vertices have the occupancy value known, i.e., the clusters with parking data, while the rest has undetermined occupancy, i.e., the clusters without parking data.
	At each step, the value for a vertex whose value is undetermined is being computed by considering the occupancies of the linked vertices and their corresponding similarity values.
\end{enumerate} 


\section{Conclusion}
In this work, we have presented an attempt at approximating street parking occupancy in cities.
Under the assumption that parking data is lacking, in order to build scalable occupancy prediction systems, we proposed an alternative solution to the ones previously developed for this problem.
We built parking demand profiles by using complementary city data, which localize various types of public amenities and indicate the average visiting duration there.
All data has been made available in an established RDF format, so that it can be easily reused.
We merged the \textit{parking data} with the \textit{city data} by matching parking \textit{location units} to \textit{points of interest}, split the city into clustered areas, and built machine learning models for them.
K-Means was used to cluster the location units, while four methods were employed to train models for the clusters: decision trees, support vector machines, multilayer perceptrons and extreme gradient boosting.
Based on the city data, urban measures were built in the form of \textit{cluster vectors} and \textit{cluster Gaussians}, both of which took advantage of the mean visiting duration and its standard deviation.
The vectors were part of the \textit{cosine similarity} computation, while Gaussians contributed to the \textit{earth mover's distance} calculation.
The occupancy estimations for clusters \textit{without} parking data were defined in terms of model estimations from clusters \textit{with} parking data and the corresponding cluster similarity values.
The estimations are expressed as intervals which extend the model prediction values by the magnitude of the similarity values. 

As use case, we chose the SF\textit{park} project from San Francisco, which gathered parking data for more than 2 years starting in 2011 and now offers it for free usage.
The city data was collected from OpenStreetMap as amenity information, and from Google Places as stay duration values.
Both sources are open and free of charge.
Over 30 types of public amenities were found in the San Francisco blocks, which corroborated with over 470 Google Places sources, lead to building the urban measures and similarity values. 

The results confirmed that clustering the city into smaller areas yields better occupancy estimations than those of entire city area models.
Following our tests, the best machine learning model turned out to be \textit{extreme gradient boosting}.
We used the clusters \textit{with} parking data for the evaluation of the similarity values and calculated correlation coefficients between the similarity values and the estimation errors, using both absolute values and ranks.
The best correlation were reached for the 100m merge distance for 8 clusters, averaging at $-0.55$ as Pearson Coefficient and $-0.49$ as Spearman's rank coefficient.
In the same configuration, both \textit{cosine similarity} and \textit{EMD distance} reached their best results from all the test configurations.
Overall, \textit{cosine similarity} achieved better correlations than \textit{emd}.
Finally, the models for 8 clusters produced superior results over the models for 16 clusters. 

{\color{green}(add conclusion of new results)}

%\begin{acks}
%  The authors would like to thank Dr. Yuhua Li for providing the
%  MATLAB code of the \textit{BEPS} method.
%
%  The authors would also like to thank the anonymous referees for
%  their valuable comments and helpful suggestions. The work is
%  supported by the \grantsponsor{GS501100001809}{National Natural
%    Science Foundation of
%    China}{http://dx.doi.org/10.13039/501100001809} under Grant
%  No.:~\grantnum{GS501100001809}{61273304}
%  and~\grantnum[http://www.nnsf.cn/youngscientists]{GS501100001809}{Young
%    Scientists' Support Program}.
%\end{acks}

